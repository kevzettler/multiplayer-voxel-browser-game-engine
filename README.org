* Multiplayer voxel browser game engine
[[./gameplay.gif]]

    #+BEGIN_HTML
<a href='/img/multiplayer-engine-post/play.gif'>
  <img src='/img/multiplayer-engine-post/play.gif'
       alt="Animated give of a 3d multiplayer browser engine"
       title="Demonstartion of multiplayer game engine multilpe players" />
</a>
#+END_HTML


This repository contains code for a prototype multiplayer voxel browser game engine. The following README is a look at the technical design and architecture of the engine. For more information on the history and motivation of this project checkout the blog post

** Computation Architecture
This engine is multi threaded using webworkers. The main thread handles the browser APIS: input, networking, rendering. There is one [[./src/browser.worker.ts][simulation worker thread]] that runs the game simulation loop. The simulation worker thread then renders using the [[https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas][offscreen canvas API]]. Messages are passed to the worker thread over the browser [[https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage][postmessage api]]. The server runs the same worker simulation thread but messages are passed over the network instead. This keeps the simulation running at max tick rate and keeps the main render thread at max FPS.

** Asset Pipeline
The whole asset pipeline is built around the [[https://github.com/mikolalysenko/ao-mesher][aomesher]] and the complementary ao-shader. Voxels are stored in 3-Dimensional 32bit integer array [[https://github.com/scijs/ndarray][ndarrays]] The ndarrays are created in in x,y,z dimensions that match the source voxel files. The voxel color palette data is then stored within the ndarray as a 32bit integer.

The asset pipeline parses ~.vox~ and ~.qb~ format voxel models and converts to a custom ~.aomesh~ format. ~.vox~ models are used for static environment models. ~.qb~ models are used for segmented character models that are later bound to skeletal animation data. The ~.qb~ files store a combination of joint + color values. The ~.aomesh~ format is an interleaved binary vertex format that captures follows the [[https://github.com/mikolalysenko/ao-mesher/blob/master/mesh.js#L21][aomesher vertex format]]

#+begin_quote
 x, y, z, ambient occlusion, normal_x, normal_y, normal_z, tex_id
#+end_quote

The ~.aomesh~ models can be generated with the ~npm run build:meshes~ command.

*** Animation
The animation system uses [[https://github.com/chinedufn/skeletal-animation-system][Skeletal animation system]] The skeletal animations are baked in a blender file then the animations are exported to JSON using [[https://docs.rs/landon/latest/landon/][landon]].
The animations are linked to ~.qb~ files at build time in the [[./scripts/QBToAOVerts.js#L65][QBToAOVerts.js]] script. The Blender to JSON animation pipeline is depressingly brittle. There is a list of Landon and Blender dependencies [[./scripts/landon_export_actions.sh][documented in the landon export script]].

** Rendering
The engine has a stateless rendering function influenced by react. An offscreen canvas reference is passed from the main thread to the simulation worker. The game state from the ECS is passed to a render function. The rendering function uses ~react-regl~ to which is wrapper for [[https://github.com/regl-project/regl/][regl]].

** Game State & Entity Component System (ECS)
The ECS is not a pure ECS with strict flat buffer memory arrangement. The engine uses a custom entity component system powered by [[https://mobx.js.org/README.html][mobx]]. It's more of a mixin system. Entities are classes composed of mixins. Each mixin is a class that has its own related state. Mixins then use mobx's ~computed~ and and ~observable~ helpers to dynamically derive entity state.

** Physics and Collision
+ Broad phase
Broad phase collision uses AABB to AABB. Each frame checks all entities for AABB collisions. This could be improved with some spatial partitioning quad tree system or something.

+ Narrow phase
Narrow phase collision uses swept sphere triangle collision based on the awesome paper [[http://www.peroxide.dk/papers/collision/collision.pdf][Improved Collision detection and Response" by Kasper Fauerby]]. When a broad phase collision is detected the narrow phase detection starts. Narrow phase currently only happens on player collision capsules against environment entities.

** Networking
The networking code uses WebRTC. The WebRTC connection is set to run in unreliable mode which supposedly removes some overhead reliability checks and is equivilent to running in UDP instead of TCP. The server uses a node.js webrtc implementation and acts as a headless peer. A [[https://github.com/mafintosh/signalhub][Signalhub]] server is used to broker the WebRTC handshake. In production a Coturn server is used to establish STUN/TURN Nat punch through

** Usage and development workflow

*** Installation
This was built against ~node v12.21.0~ and hasn't been tested with later versions. Try upgrading at your own risk

clone this repo and ~npm install~

*** running locally
The engine can be started with:

#+begin_src
npm run dev
#+end_src

This is a combined command that will startup several processes. It will take ~15 seconds to startup due to some unfortunate sequential sleep commands. The app will be accessible on https://localhost:3000 when ready.


** License
CC BY-NC-SA
